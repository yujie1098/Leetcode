*** Dynamic Programming ***
## 理论基础 ##
    动态规划是自底向上地解决问题
    动态规划通过将复杂问题拆解成较小且重复的子问题来解决问题，每个子问题只解决一次，并将结果存储在一个表格中
    ❗️动态规划中每一个状态一定是由上一个状态推导出来的❗️
    * Diff w Greedy *
        贪心也是局部直接选最优的，但是Greedy没有状态推导

## Steps ##
    一定要按照这五步做，会更简单:
        1.确定dp数组以及下标的含义
        2.确定递推公式/状态转移方程
        3.dp数组如何初始化
        4.确定遍历顺序
        5.举例推导dp数组验证状态前4步

## Topic Summary ##
    1.背包问题
        1.1.概述
          ├── 背包
          │   └── 最大容量 W
          └── 物品
              ├── 价值 v[]
              ├── 体积 w[]
              └── 每个物品的数量
                  ├── 只有一个
                  │   ├── 不选
                  │   └── 选一个
                  │       └── 0/1 背包
                  └── 无数个
                      ├── 不选
                      └── 选几个
                          └── 完全背包
        1.2.背包问题的遍历顺序
            遍历顺序包括: 双重循环内外次序; 单个循环的遍历顺序;
            1.01Bags二维dp: 都行;正序;
            2.01Bags一维dp: 先物品再容量;内循环倒序;
                                      1.倒序会让第i-1层的值得到保留;01背包问题需要上一层(i-1)的dp[j]的值(从二维数组的递推公式看出来)
                                      2.倒序能保证物品i只被放入一次;因为01背包中所有的物品只能使用一次
            3.CompleteBags二维dp: 都行;正序;
            4.CompleteBags一维dp: 都行;内循环正序;
                                            1.不需要倒序;完全背包问题不需要上一层(i-1)的dp[j]的值(从二维数组的递推公式看出来)
                                            2.不能倒序;正序使得每次装物品都允许多次使用同一物品,完全背包中的物品可以被使用无限次
        1.3.递推公式/状态转移
            求装满背包有几种方法,递推公式一般为:
                dp[j] += dp[j - nums[i]];
        1.4.例题
            01Bags:
                P416: 求给定背包容量，能不能装满这个背包
                P1049: 求给定背包容量，尽可能装，最多能装多少容量
                P494: 求给定背包容量，装满背包有多少种方法
                P474: 求给定背包容量，装满背包最多有多少个物品
            CompleteBags:
                P518
                P377
                P70
                P322
                P279
                P139
        1.5.其他
            看到sum和array同时出现，就可以考虑是不是能用背包做

    2.拆数问题
        2.1.例题
            P96 P343
            (完全背包问题) P279 P322 P518
    3.强盗问题

    4.股票问题

    5.子序列问题

    求组合数：如果求组合数就是外层for循环遍历物品，内层for遍历背包 P518 P494
        求组合类问题的公式，都是类似这种：dp[j] += dp[j - nums[i]]
    求排列数：如果求排列数就是外层for遍历背包，内层for循环遍历物品 P377
    其他：不强调集合是组合还是排列，内外层是谁都可以 P322

    1.对于一个状态可以从两种或多种途径获得，递推公式就用+连接所有途径，一般用来求最多个数/路径等
        P62 P63 P70
    2.对于一个状态可以从多个途径获得，但是要求获得一个最小值或者最大值，那么用max/min()来保存最优值
        P746 P343



## DBUG ##
    1.做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果。
    2.然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。
    3.如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。
      如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。
    这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了