** BackTracking **
    回溯是一种通过试错的方法来解决问题的算法，纯暴力搜索方法，尤其是在搜索问题中寻找所有（或部分）解的场景，
    当它通过尝试可能的完成路径发现现有的部分解不可行时，它会撤销上一步甚至是几步的计算，再通过其他可能的分支继续尝试。
    回溯则是递归的一种应用形式，只要有递归就会有回溯。
    虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法。(md没一点好处)
* case *
        回溯法，一般可以解决如下几种问题：
            组合问题：N个数里面按一定规则找出k个数的集合
            切割问题：一个字符串按一定规则有几种切割方式
            子集问题：一个N个数的集合里有多少符合条件的子集
            排列问题：N个数按一定规则全排列，有几种排列方式
            棋盘问题：N皇后，解数独等等
* Steps *
        回溯法解决的问题都可以抽象为树形结构，做题前先画一个树结构
        因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度就构成了树的深度。
        !!最重要的是要会画树!!
        1.回溯函数模板返回值以及参数
            回溯算法中函数返回值一般为void。
            回溯算法需要的参数不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。
        2.回溯函数终止条件
            if (终止条件) {
                存放结果;
                return;
            }
        3.回溯搜索的遍历过程
            for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
                处理节点;
                backtracking(路径，选择列表); // 递归
                回溯，撤销处理结果
            }
        4.总结
            void backtracking(参数) {
                if (终止条件) {
                    存放结果;
                    return;
                }
                for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
                    处理节点;
                    backtracking(路径，选择列表); // 递归
                    回溯，撤销处理结果
                }
            }
** Time Complexity **
    !!最重要的是要会画树!!
    递归树的宽度^递归树的深度 * 单层语句的时间复杂度(在每个结点进行的操作的时间复杂度)
    或者说 树的结点树 * 单层语句的时间复杂度(在每个结点进行的操作的时间复杂度)
** Space Complexity **
    递归栈深度 + 结果存储空间
        在递归过程中，每一层递归都会在调用栈上占用一定的空间。这通常包括函数参数、局部变量和返回地址。