*** Dynamic Programming ***
    动态规划是自底向上地解决问题
    动态规划通过将复杂问题拆解成较小且重复的子问题来解决问题，每个子问题只解决一次，并将结果存储在一个表格中。
** 应用 **
    当遇到一个问题并考虑使用动态规划时，可以根据以下特征来判断：
    1. 重叠子问题（Overlapping Subproblems）
        如果一个问题的解决过程中多次求解相同的子问题，而不是生成新的子问题，那么这种情况就称为重叠子问题。
        这是动态规划适用的一个重要信号。
        在这种情况下，动态规划可以通过保存已解决的子问题的结果（通常是在一个表中）来避免重复计算，大幅提高效率。
    2. 最优子结构（Optimal Substructure）
        一个问题的最优解包含其子问题的最优解。
        换句话说，问题的整体最优解可以通过组合其子问题的最优解来获得。
        如果一个问题可以展现出这种结构，那么动态规划很可能是一个有效的解决方案。
    3. 可以通过决策来递推（Decision Process）
        如果一个问题可以通过一系列的选择（即决策）来解决，并且每一步的决策依赖于之前步骤的状态，那么这个问题可能适合用动态规划来解决。
        这种问题通常可以用状态转移方程来描述，每个状态表示一个决策阶段的结果。
** Steps **
    画表格
    1.确定dp[][]含义
    2.确定递推公式 dp[][] = ;
    3.初始化赋值
** 技巧 **
    求组合数：如果求组合数就是外层for循环遍历物品，内层for遍历背包 P518 P494
        求组合类问题的公式，都是类似这种：dp[j] += dp[j - nums[i]]
    求排列数：如果求排列数就是外层for遍历背包，内层for循环遍历物品 P377
    其他：不强调集合是组合还是排列，内外层是谁都可以 P322

    背包问题: 背包问题一维dp的遍历，nums放在外循环，target在内循环
    01背包问题：
        内循环倒序:倒序遍历是为了保证物品i只被放入一次！如果一旦正序遍历了，那么物品0就会被重复加入多次！
    完全背包问题:
        内循环正序:在完全背包问题中，内循环需要从小到大进行，以允许多次使用同一物品